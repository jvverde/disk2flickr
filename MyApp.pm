# generated by wxGlade 0.6.8 (standalone edition) on Tue Oct 29 09:46:14 2013
#
# To get wxPerl visit http://wxPerl.sourceforge.net/
#
use Wx 0.15 qw[:allclasses];
use strict;
use MyFlickr;
use Digest::SHA qw(sha256);
use File::HomeDir;
use Cwd qw{abs_path};
use threads;
use threads::shared;
use Thread::Queue;
#use Thread::Semaphore;
use Data::Dumper;
use JSON;
use Encode::Locale;
use Encode;
######################my code ######################################

$\ = "\n";

my $flickr = MyFlickr->new();
my $matching_pattern :shared = '.';
my $stop = 0;
my @tags = ();

my $filesQ = Thread::Queue->new(); #mark queue
my $fileIDQ = Thread::Queue->new(); #mark queue
my $checkFlickrQ = Thread::Queue->new(); #mark queue
my $uploadQ = Thread::Queue->new(); #mark queue
my $foldersQ = Thread::Queue->new(); #mark queue
#my $filesS = Thread::Semaphore->new(50);
#my $stopS = Thread::Semaphore->new(0);
my $home = File::HomeDir->my_home;


my $dbfile = qq|$home/.disk2flick|;
#my $json  = JSON->new->utf8->pretty;
my $json  = JSON->new->utf8;
sub openDB{
  my ($file) = @_;
  return {} unless -r $file;  
  my $result = {};
  eval{
	local $/;
	open F, '<', "$file" or die "Cannot open $file";
	my $json_text   = <F>;
	close F;
	$result = $json->decode( $json_text );
  };
  warn $@ if $@;
  return $result;
}
my $db = shared_clone openDB($dbfile);

$db->{cnt}++;
$db->{users} //= shared_clone {};
$flickr->{user} = $db->{users}->{$db->{currentUser}}->{flickr}->{usr}
	if $db->{currentUser}
		and defined $db->{users}->{$db->{currentUser}}
		and defined $db->{users}->{$db->{currentUser}}->{flickr};

#print Dumper $db;

my $syncDB = sub{
	open F, '>', $dbfile;
	print F $json->encode($db);
	close F;
};

######some stuff to deal with the resources release of finished threads#####
my @finishedThreads :shared = ();
my $releaseResourcesT = async{
	while(1){
		lock @finishedThreads;
		cond_wait(@finishedThreads) until @finishedThreads > 0;
		foreach(@finishedThreads){
			threads->exit() unless defined $_;
			my $t = threads->object($_);
			$t->join() if defined $t;
		}
		undef @finishedThreads;
	}
};

my $releaseThisThread = sub{ #should me called from a thread which is finishing 
	lock @finishedThreads;
	push @finishedThreads, threads->self()->tid();
	cond_signal @finishedThreads;
};
my $wait4TheseThreads2Join = sub{
	$_->join() foreach(@_);
};

###sync from flickr stuff #####
my $syncingFlickr :shared = 0;
sub syncFlickr{
	{ 
		lock $syncingFlickr;
		return if $syncingFlickr; #ignore the request if a sync is already in progress
		$syncingFlickr = 1;
	}
	async{
		eval{
			print "Start sync from flickr for user $db->{currentUser}";
			my $photos = $flickr->checkAllFlickrPhotos();
			print "Sync from flickr finished";
			$db->{users}->{$db->{currentUser}}->{flickr}->{photos} = $photos;
			$db->{users}->{$db->{currentUser}}->{lastsync} = time;
		};
		warn $@ if $@;
		lock $syncingFlickr;
		$syncingFlickr = 0;
		cond_signal($syncingFlickr);
		$releaseThisThread->();
	};
}
sub checkShared{
	$db->{users}->{$db->{currentUser}} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{photos} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{photos}->{photosIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{photos}->{filesIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{usr} = shared_clone($flickr->{user} // {});
	$db->{users}->{$db->{currentUser}}->{folders} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{options} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{options}->{filter} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{files} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{fileIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{photoIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{lastsync} //= 0;
}
my $loadUser = sub{
	$db->{currentUser} = $flickr->{user}->{nsid}
		if(defined $flickr->{user} and defined $flickr->{user}->{nsid});
	$db->{currentUser} //= '';
	checkShared();
	syncFlickr() if $db->{currentUser} ne '' and time - $db->{users}->{$db->{currentUser}}->{lastsync} > 3600;
	$syncDB->();
};
my $removeUser = sub{
	$db->{currentUser} = '';
	checkShared();
	$syncDB->();
};

my $pendigFiles :shared = 0;
my $uploadFiles :shared = 0;
my $uploadFinished :shared = 0;

sub countUploadedFiles{
	lock $uploadFiles;
	$uploadFiles++;
	cond_signal $uploadFiles;
}
sub countPendingFiles{
	lock $pendigFiles;
	$pendigFiles++;
	cond_signal $pendigFiles;
}

$loadUser->();

sub computeFileID{
	warn(q|getFileID: File not defined|) and return undef unless defined $_[0];
	warn(q|getFileID: File not $_[0] found|) and return undef unless -e $_[0];
	my $sha = Digest::SHA->new();
	$sha->addfile($_[0],'b');
	return $sha->hexdigest;
}

sub getFolder{
	my $dir = shift;
	print qq|Get dir $dir|;
	my @steps = split /\/|\\/, $dir;
	my $step = $steps[$#steps];
	if ($step =~ qr/$matching_pattern/){
		getFiles($dir);
	}
	getSubFolders($dir);
}

sub getSubFolders{
	my $dir = shift;
	eval{
		opendir DIR, $dir or die qq|Wasn't possible to open folder $dir : $!|;
		my @subdirs = grep {-d qq|$dir/$_| and $_ ne '.' and $_ ne '..'} readdir DIR;
		closedir DIR;
		foreach my $subdir (@subdirs){
			getFolder(qq|$dir/$subdir|);
		}
	};
	warn $@ if $@;
}

sub getFiles{
	my ($dir) = @_;
	eval{
		opendir DIR, $dir or die qq|Wasn't possible to open folder $dir : $!|;

		my @files = grep {/\.(jpg|png)$/i} readdir DIR;
		foreach (@files){
			my $path = abs_path(qq|$dir/$_|);
			$filesQ->enqueue($path) if defined $filesQ->pending();
		}
	};
	warn $@ if $@;
}

my %threads = ();

my $startThreads = sub{
	return (
		threads->create({exit => 'threads_only'}, sub {
			while(1){
				eval{
					while (defined(my $folder = $foldersQ->dequeue())){
						{
							lock $syncingFlickr;
							cond_wait($syncingFlickr) while($syncingFlickr);
						}
						my $foldername = encode(locale => $folder);
						getFolder($foldername);
					}
				};
				(warn "$@\nI will Try again"), next if $@;
				$filesQ->enqueue(undef) if defined $filesQ->pending();
				$releaseThisThread->();
				threads->exit();
				last;
			}
		}),
		threads->create({exit => 'threads_only'}, sub {
			while(1){
				eval{
					while (defined(my $filename = $filesQ->dequeue())){
						my $mtime =  (stat($filename))[9];
						if(defined $db->{users}->{$db->{currentUser}}->{files}->{$filename}
							and $db->{users}->{$db->{currentUser}}->{files}->{$filename}->{mtime} eq $mtime
						){
							print "File $filename was previously uploaded and was not modified since then";
						}else{
							$fileIDQ->enqueue({filename=>$filename,mtime=>$mtime}) if defined $fileIDQ->pending();
						}
					}
				};
				(warn "$@\nI will Try again"), next if $@;
				$fileIDQ->enqueue(undef) if defined $fileIDQ->pending();
				$releaseThisThread->();
				threads->exit();
				last;
			}
		}),
		threads->create({exit => 'threads_only'}, sub {
			while(1){
				eval{
					while (defined(my $file = $fileIDQ->dequeue())){
						my $id = computeFileID($file->{filename});
						if (defined $db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}){
							if( defined $db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}->{filename}
								and lc $file->{filename} eq lc $db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}->{filename}
							){
								print "File $file->{filename} was previously uploaded";
							}else{
								print "File $file->{filename} was previously uploaded under a different name: $db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}->{filename}";
								$db->{users}->{$db->{currentUser}}->{files}->{$file->{filename}} = shared_clone $file;
							}
						}else{
							$file->{id} = $id;
							$checkFlickrQ->enqueue($file) if defined $checkFlickrQ->pending();
						}
					}
				};
				(warn "$@\nI will Try again"), next if $@;
				$checkFlickrQ->enqueue(undef) if defined $checkFlickrQ->pending();
				$releaseThisThread->();
				threads->exit();
				last;
			}
		}),
		threads->create({exit => 'threads_only'}, sub {
			while(1){
				eval{
					while (defined(my $file = $checkFlickrQ->dequeue())){
						unless (defined $db->{users}->{$db->{currentUser}}->{flickr}->{photos}->{filesIDs}->{$file->{id}}){
							$uploadQ->enqueue($file) if defined $uploadQ->pending();
							countPendingFiles();
						}else{
							print "File ($file->{filename}) already on flick. Won't duplicate";
							$db->{users}->{$db->{currentUser}}->{files}->{$file->{filename}}
								= $db->{users}->{$db->{currentUser}}->{fileIDs}->{$file->{id}}
								= shared_clone $file;							
						}
					}
				};
				(warn "$@\nI will Try again"), next if $@;
				$uploadQ->enqueue(undef) if defined $uploadQ->pending();
				$releaseThisThread->();
				threads->exit();
				last;
			}
		}),
		map {threads->create({exit => 'threads_only'}, sub {
			while(1){
				eval{
					while (defined(my $file = $uploadQ->dequeue())){
						my @localtags = (
						  $file->{id},
							qq|dir:filename="$file->{filename}"|,
							qq|meta:id="$file->{id}"|,
							qq|time:modification="$file->{mtime}"|,
							map {qq|dir:step="$_"|} grep {/[^\s]/} split /\//, $file->{filename}
						);
						#print "Prepare to upload $file->{filename}";
						my $photoid = $flickr->upload($file->{filename},@tags, @localtags) or next;
						print "File $file->{filename} uploaded to flickr (photoid = $photoid)";
						$file->{photoid} = $photoid;
						$db->{users}->{$db->{currentUser}}->{files}->{$file->{filename}}
							= $db->{users}->{$db->{currentUser}}->{fileIDs}->{$file->{id}}
							= $db->{users}->{$db->{currentUser}}->{photoIDs}->{$file->{photoid}} 
							= shared_clone $file;
						countUploadedFiles();				
						$syncDB->();
					}
				};
				(warn "$@\nI will Try again"), next if $@;
				$releaseThisThread->();
				threads->exit();
				last;
			}
		})} (0..1) 
	)
};

my $stopThreads = sub{
	$filesQ->end;
	$fileIDQ->end;
	$checkFlickrQ->end;
	$uploadQ->end;
	{ #prepare to stop releaseResourcesT thread
		lock @finishedThreads;
		push @finishedThreads, (undef);
		cond_signal @finishedThreads;
	}
	$wait4TheseThreads2Join->($releaseResourcesT);
};
######################End of my code ######################################


package MyApp;
use Wx qw[:everything];
use parent qw(MyFrame);
use strict;
use Data::Dumper;
use Carp;
use threads;
use threads::shared;

######aux functions#########################

sub __showMainPanel{
	my ($self) = @_;
	$self->{mainPanel}->Show(1);
	$self->__hideLoginPanel();
	$self->{mainPanel}->GetParent()->GetSizer()->Layout();
}
sub __hideMainPanel{
	my ($self) = @_;
	$self->{mainPanel}->Show(0);
}
sub __showLoginPanel{
    my ($self) = @_;
	$self-> __hideMainPanel();
	$self->{getTokenPanel}->Show(0);
	$self->{loginPanel}->Show(1);
	$self->{loginPanel}->GetParent()->GetSizer()->Layout();
	$self->__showAskAuthPanel();
}
sub __hideLoginPanel{
	my ($self) = @_;
	$self->{loginPanel}->Show(0);
}
sub __showCheckTokenPanel{
	my ($self) = @_;
	$self->__hideAskAuthPanel();
	$self->{getTokenPanel}->Show(1);
	$self->{getTokenPanel}->GetParent()->GetSizer()->Layout();
}
sub __hideCheckTokenPanel{
	my ($self) = @_;
	$self->{getTokenPanel}->Show(0);
}
sub  __showAskAuthPanel{
	my ($self) = @_;
	$self->__hideCheckTokenPanel();
	$self->{askAuthPanel}->Show(1);
	$self->{askAuthPanel}->GetParent()->GetSizer()->Layout();
}
sub  __hideAskAuthPanel{
	my ($self) = @_;
	$self->{askAuthPanel}->Show(0);
}

sub __setStatus{
	my ($self) = @_;
	if ($db->{currentUser} ne ''){
		my $name = $db->{users}->{$db->{currentUser}}->{flickr}->{usr}->{fullname};
		utf8::decode($name);
		$self->SetStatusText(
		  'User '
		  .  $name
		  . '('
		  . $db->{users}->{$db->{currentUser}}->{flickr}->{usr}->{username}
			. ')'
		,0);
	}else{
				$self->SetStatusText('The user is not yet authorized',0);
	}
}

sub __setUserOptions{
	my ($self) = @_;
	my $p = 0;
	foreach (sort keys $db->{users}->{$db->{currentUser}}->{folders}){
		$self->{foldersList}->InsertStringItem($p++,$_);
	}
	#$db->{users}->{$db->{currentUser}}->{options}
	#$db->{users}->{$db->{currentUser}}->{options}->{filter} = shared_clone {some => $choice};
	$self->{backupRecursiveOptionSomeChoiceValue}->ChangeValue( 
		$db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}->{value}
	) if defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}
		and defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}->{value};
	$self->{backupRecursiveOptionSomeChoiceName}->SetValue(
		$db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}->{action}
	) if defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}
		and defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}->{action};
	$self->{backupRecursiveOptionSome}->SetFocus()
		if defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}
		and defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}->{action}	
		and defined $db->{users}->{$db->{currentUser}}->{options}->{filter}->{some}->{value};	
}

###############################

sub new {
    my( $self) = @_;
	$self = $self->SUPER::new();

	$self->SetSize(Wx::Size->new(550, 450));
	Wx::Event::EVT_CLOSE($self,sub{
			my ($self, $event) = @_;
			$stopThreads->();
			$syncDB->();
			print "Goodby";
			$event->Skip;
	});

	if($db->{currentUser} ne ''
	   	and defined $db->{users}->{$db->{currentUser}}
	   	and defined $db->{users}->{$db->{currentUser}}->{flickr}
	  	and defined $db->{users}->{$db->{currentUser}}->{flickr}->{usr}
	   	and defined $db->{users}->{$db->{currentUser}}->{flickr}->{usr}->{auth_token}){
		$self->__showMainPanel();
		$self->__setUserOptions();
	}else{
		$self->__showLoginPanel();
	}
	$self->__setStatus();
	$self->{uploadProgressBar}->SetRange(100);
	$self->{uploadProgressBar}->SetValue(0);
	$self->{syncProgressPanel}->Hide();
	$self->{uploadProgressPanel}->Hide();
	return $self;
}

sub go_login {
	my ($self) = @_;
	$self->__showLoginPanel();
}

sub go_logout {
	my ($self) = @_;
	$removeUser->();
	$syncDB->();
	$self->__showLoginPanel();
	$self->SetStatusText('The user is not authorized anymore',0);
}

my $lastDirectory = "";
sub go_browse {
	my ($self) = @_;
	my $dlg = Wx::DirDialog->new(
	  $self->{backupSubPanel},
	  "Please, choose a folder to backup",
	  $lastDirectory,
	  wxDD_CHANGE_DIR|wxDD_DIR_MUST_EXIST
	);
	if ($dlg->ShowModal == wxID_OK){
		$lastDirectory = $dlg->GetPath();
		my $p = $self->{foldersList}->GetItemCount;
		$self->{foldersList}->InsertStringItem($p,$lastDirectory);
		$db->{users}->{$db->{currentUser}}->{folders}->{$lastDirectory} = time;
	}
}

sub go_remove_selected {
	my ($self) = @_;
	my $removeFromDB = sub{
		delete $db->{users}->{$db->{currentUser}}->{folders}->{$self->{foldersList}->GetItemText(shift)};
	};
	my $p = $self->{foldersList}->GetFirstSelected;
	$removeFromDB->($p);
	$self->{foldersList}->DeleteItem($p);
	while(($p = $self->{foldersList}->GetNextSelected($p)) >= 0){
		$removeFromDB->($p);
		$self->{foldersList}->DeleteItem($p)
	}
}

sub go_remove_all {
	my ($self) = @_;
	$self->{foldersList}->ClearAll;
	$db->{users}->{$db->{currentUser}}{folders} =  shared_clone{};
}

sub go_backup {
	my ($self) = @_;
	unless(defined $flickr->{user} and defined $flickr->{user}->{nsid}){
		print "User not login";
		return $self->go_login();
	}
	$pendigFiles = 0;
	$uploadFiles = 0;
	my $progressText :shared = $self->{uploadProgressBarSizer_staticbox}->GetLabelText();
	$progressText =~ s/[0-9)(:].*$//;
	async{ #Thread #pending: Adjust progressbar as files are waiting update
		my $p = $pendigFiles;
		while(1){
			lock($pendigFiles);
			cond_wait($pendigFiles) until $pendigFiles != $p;
			last unless $pendigFiles >= 0;
			$self->{uploadProgressBar}->SetRange($p = $pendigFiles);
			$self->{uploadProgressBarSizer_staticbox}->SetLabel(
				qq|$progressText: ($uploadFiles of $pendigFiles) done|
			);
		}
		$releaseThisThread->();
	};
	async{ #Thread #update: update progessbar
		my $u = $uploadFiles;
		while(1){
			lock($uploadFiles);
			cond_wait($uploadFiles) until $uploadFiles != $u;
			last unless $uploadFiles >= 0;
			$self->{uploadProgressBar}->SetValue($u = $uploadFiles);
			$self->{uploadProgressBarSizer_staticbox}->SetLabel(
				qq|$progressText: ($uploadFiles of $pendigFiles) done|
			);
		}
		$releaseThisThread->();
	};
	async{
		$self->{uploadProgressPanel}->Show(1);
		$self->{uploadProgressPanel}->Raise();
		$startThreads->();
		#$wait4TheseThreads2Join->($startThreads->()); #start threads and wait;ock 
		lock $uploadFinished;
		cond_wait $uploadFinished until $uploadFinished == 1;
		$self->{uploadProgressPanel}->Hide();
		my $p = $pendigFiles;
		my $u = $uploadFiles;
		{
			lock $pendigFiles;
			$pendigFiles = -1 -$u; #set condition to end the thread #pending
			cond_signal $pendigFiles;
		}		
		{
			lock $uploadFiles;
			$uploadFiles = -1 -$p; #set condition to end the thread #update
			cond_signal $uploadFiles;
		}
		$releaseThisThread->();
	};
	my $count = $self->{foldersList}->GetItemCount;
	my $i = 0;
	while($i < $count){
		print $self->{foldersList}->GetItemText($i);
		$foldersQ->enqueue($self->{foldersList}->GetItemText($i++));
	}
	$foldersQ->enqueue(undef); #signal the end of folders list
}

sub go_exit {
	my ($self) = @_;
	$self->Close;
}

sub go_close {
	my ($self) = @_;
	$self->Close;
}

sub go_main {
	my ($self) = @_;
	$self->__showMainPanel();
}

sub go_askAuth {
	my ($self) = @_;
	$flickr->askAuth() or carp q|ask auth error|;
	$self->__showCheckTokenPanel();
}

sub go_getToken {
	my ($self) = @_;
	print 'Get token...';
	$flickr->getToken() or return $self-> __showAskAuthPanel();
	$self->__showMainPanel();
	$loadUser->();
	$self->__setStatus();
}

sub go_matching_all{
	$matching_pattern = '.+';
	$db->{users}->{$db->{currentUser}}->{options}->{filter} = shared_clone {all => 1};	
}
sub _pattern{
	my ($self) = @_;
	my $choice = {};
    my $action = $self->{backupRecursiveOptionSomeChoiceName}->GetValue();		
    my $value = $self->{backupRecursiveOptionSomeChoiceValue}->GetValue();
	if ($action eq 'is equal to'){
		$matching_pattern = qq|^$value\$|;
		$choice = {action => 'is equal to', value => $value};
	}elsif($action eq 'not equal to'){
		$matching_pattern = qq|^(?!$value\$).+\$|;	
		$choice = {action => 'not equal to', value => $value};
	}elsif($action eq 'contains'){
		$matching_pattern = qq|$value|;	
		$choice = {action => 'contains', value => $value};
	}elsif($action eq 'not contains'){
		$matching_pattern = qq|^(?!.*$value).|;	
		$choice = {action => 'not contains', value => $value};
	}elsif($action eq 'starts with'){
		$matching_pattern = qq|^$value|;	
		$choice = {action => 'starts with', value => $value};
	}elsif($action eq 'not starts with'){
		$matching_pattern = qq|^(?!$value).|;	
		$choice = {action => 'not starts with', value => $value};
	}elsif($action eq 'ends with'){
		$matching_pattern = qq|$value\$|;	
		$choice = {action => 'ends with', value => $value};
	}elsif($action eq 'ends with'){
		$matching_pattern = qq|^(?!.*$value\$).|;	
		$choice = {action => 'ends with', value => $value};
	}else{
		$matching_pattern = qq|^\$|;	
		$choice = {action => ''};
	}
	print $matching_pattern;
	$db->{users}->{$db->{currentUser}}->{options}->{filter} = shared_clone {some => $choice};	
}
sub go_matching_some{
	shift->_pattern;
	#$matching_pattern = qr/^$/;
}
sub go_matching_action{
	shift->_pattern;
}
sub go_matching_text_enter{
	shift->_pattern;
}

1;

