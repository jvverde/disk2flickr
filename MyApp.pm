# generated by wxGlade 0.6.8 (standalone edition) on Tue Oct 29 09:46:14 2013
#
# To get wxPerl visit http://wxPerl.sourceforge.net/
#
use Wx 0.15 qw[:allclasses];
use strict;
use MyFlickr;
use Digest::SHA qw(sha256);
use File::HomeDir;
use Cwd qw{abs_path};
use threads;
use threads::shared;
use Thread::Queue;
#use Thread::Semaphore;
use Data::Dumper;
use JSON;
use Encode::Locale;
use Encode;
######################my code ######################################

$\ = "\n";

my $flickr = MyFlickr->new();
my $pattern = qr/./;
my $stop = 0;
my @tags = ();

my $filesQ = Thread::Queue->new(); #mark queue
my $fileIDQ = Thread::Queue->new(); #mark queue
my $checkFlickrQ = Thread::Queue->new(); #mark queue
my $uploadQ = Thread::Queue->new(); #mark queue
my $foldersQ = Thread::Queue->new(); #mark queue
#my $filesS = Thread::Semaphore->new(50);
#my $stopS = Thread::Semaphore->new(0);
my $home = File::HomeDir->my_home;


my $dbfile = qq|$home/.disk2flick|;
#my $json  = JSON->new->utf8->pretty;
my $json  = JSON->new->utf8;
sub openDB{
  my ($file) = @_;
  return {} unless -r $file;  
  my $result = {};
  eval{
	local $/;
	open F, '<', "$file" or die "Cannot open $file";
	my $json_text   = <F>;
	close F;
	$result = $json->decode( $json_text );
  };
  warn $@ if $@;
  return $result;
}
my $db = shared_clone openDB($dbfile);

$db->{cnt}++;
$db->{users} //= shared_clone {};
$flickr->{user} = $db->{users}->{$db->{currentUser}}->{flickr}->{usr}
	if $db->{currentUser}
		and defined $db->{users}->{$db->{currentUser}}
		and defined $db->{users}->{$db->{currentUser}}->{flickr};

#print Dumper $db;

my $syncDB = sub{
	open F, '>', $dbfile;
	print F $json->encode($db);
	close F;
};

my $syncingFlickr :shared = 0;
sub syncFlickr{
	{ #create a local scope for lock
		lock $syncingFlickr;
		return if $syncingFlickr;
		$syncingFlickr = 1;
	}
	async{
		eval{
			print "Start sync from flickr for user $db->{currentUser}";
			my $photos = $flickr->checkAllFlickrPhotos();
			print "Sync from flickr finished";
			$db->{users}->{$db->{currentUser}}->{flickr}->{photos} = $photos;
			$db->{users}->{$db->{currentUser}}->{lastsync} = time;
		};
		warn $@ if $@;
		lock $syncingFlickr;
		$syncingFlickr = 0;
		cond_signal($syncingFlickr);
	};
}
sub checkShared{
	$db->{users}->{$db->{currentUser}} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{photos} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{photos}->{photosIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{photos}->{filesIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{flickr}->{usr} = shared_clone($flickr->{user} // {});
	$db->{users}->{$db->{currentUser}}->{folders} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{files} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{fileIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{photoIDs} //= shared_clone {};
	$db->{users}->{$db->{currentUser}}->{lastsync} //= 0;
}
my $loadUser = sub{
	$db->{currentUser} = $flickr->{user}->{nsid}
		if(defined $flickr->{user} and defined $flickr->{user}->{nsid});
	$db->{currentUser} //= '';
	checkShared();
	syncFlickr() if $db->{currentUser} ne '' and time - $db->{users}->{$db->{currentUser}}->{lastsync} > 3600;
	$syncDB->();
};
my $removeUser = sub{
	$db->{currentUser} = '';
	checkShared();
	$syncDB->();
};

my $pendigFilesUpdated :shared = 0;
my $uploadFilesUpdated :shared = 0;
my $pendigFiles :shared = 0;
my $uploadFiles :shared = 0;

sub countUploadedFiles{
	lock $uploadFilesUpdated;
	$uploadFilesUpdated = 1;
	$uploadFiles++;
	cond_signal $uploadFilesUpdated;
}
sub countPendingFiles{
	lock $pendigFilesUpdated;
	$pendigFilesUpdated = 1;
	$pendigFiles++;
	cond_signal $pendigFilesUpdated;
}

$loadUser->();

sub computeFileID{
	warn(q|getFileID: File not defined|) and return undef unless defined $_[0];
	warn(q|getFileID: File not $_[0] found|) and return undef unless -e $_[0];
	my $sha = Digest::SHA->new();
	$sha->addfile($_[0],'b');
	return $sha->hexdigest;
}

sub getFolder{
	my $dir = shift;
	print qq|Get dir $dir|;
	if ($dir =~ $pattern){
		print qq|uploadDir dir $dir|;
		uploadDir($dir,@tags);
	}
	getSubFolders($dir);
}

sub getSubFolders{
	my $dir = shift;
	eval{
		opendir DIR, $dir or die qq|Wasn't possible to open folder $dir : $!|;
		my @subdirs = grep {-d qq|$dir/$_| and $_ ne '.' and $_ ne '..'} readdir DIR;
		closedir DIR;
		foreach my $subdir (@subdirs){
			getFolder(qq|$dir/$subdir|);
		}
	};
	warn $@ if $@;
}

sub uploadDir{
	my ($dir,@tags) = @_;
	eval{
		opendir DIR, $dir or die qq|Wasn't possible to open folder $dir : $!|;

		my @files = grep {/\.(jpg|png)$/i} readdir DIR;
		foreach (@files){
			my $path = abs_path(qq|$dir/$_|);
			$filesQ->enqueue($path) if defined $filesQ->pending();
		}
	};
	warn $@ if $@;
}

my %threads = ();

my $startThreads = sub{

	$threads{browseT} = threads->create({exit => 'threads_only'}, sub {
		while(1){
			eval{
				while (defined(my $folder = $foldersQ->dequeue())){
					{
						lock $syncingFlickr;
						cond_wait($syncingFlickr) while($syncingFlickr);
					}
					my $foldername = encode(locale => $folder);
					getFolder($foldername);
				}
			};
			(warn "$@\nI will Try again"), next if $@;
			print "Send undef to filesQ";
			$filesQ->enqueue(undef) if defined $filesQ->pending();
			threads->exit();
		}
	});

	$threads{filesT} = threads->create({exit => 'threads_only'}, sub {
		while(1){
			eval{
				while (defined(my $filename = $filesQ->dequeue())){
					my $mtime =  (stat($filename))[9];
					if(0 and defined $db->{users}->{$db->{currentUser}}->{files}->{$filename}
						and $db->{users}->{$db->{currentUser}}->{files}->{$filename}->{mtime} eq $mtime){
						print "File $filename was previously uploaded and was not modified since then";
					}else{
						$fileIDQ->enqueue({filename=>$filename,mtime=>$mtime}) if defined $fileIDQ->pending();
					}
				}
			};
			(warn "$@\nI will Try again"), next if $@;
			print "Send undef to fileIDQ";
			$fileIDQ->enqueue(undef) if defined $fileIDQ->pending();
			threads->exit();
		}
	});

	$threads{filesIDT} = threads->create({exit => 'threads_only'}, sub {
		while(1){
			eval{
				while (defined(my $file = $fileIDQ->dequeue())){
					my $id = computeFileID($file->{filename});
					if (0 and $db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}){
						my $re = qr/$db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}->{filename}/;
						if( $file->{filename} =~ /^re$/i){
							print "File $file->{filename} was previously uploaded and still have the same signature and same name";
						}else{
							print "File $file->{filename} was previously uploaded and still have the same signature but a diferente name $db->{users}->{$db->{currentUser}}->{fileIDs}->{$id}->{filename}";
							$db->{users}->{$db->{currentUser}}->{files}->{$file->{filename}} = shared_clone $file;
						}
					}else{
						$file->{id} = $id;
						$checkFlickrQ->enqueue($file) if defined $checkFlickrQ->pending();
					}
				}
			};
			(warn "$@\nI will Try again"), next if $@;
			print "Send undef to checkFlickrQ";
			$checkFlickrQ->enqueue(undef) if defined $checkFlickrQ->pending();
			threads->exit();
		}
	});

	$threads{checkFlickrT} = threads->create({exit => 'threads_only'}, sub {
		while(1){
			eval{
				while (defined(my $file = $checkFlickrQ->dequeue())){
					unless (defined $db->{users}->{$db->{currentUser}}->{flickr}->{photos}->{filesIDs}->{$file->{id}}){
						$uploadQ->enqueue($file) if defined $uploadQ->pending();
						countPendingFiles();
					}else{
						print "File ($file->{filename}) already on flick. Won't duplicate";
						$db->{users}->{$db->{currentUser}}->{files} = shared_clone $file;
						$db->{users}->{$db->{currentUser}}->{fileIDs} = shared_clone $file;
					}
				}
			};
			(warn "$@\nI will Try again"), next if $@;
			print "Send undef to uploadQ";
			$uploadQ->enqueue(undef) if defined $uploadQ->pending();
			threads->exit();
		}
	});

	$threads{uploadT} = threads->create({exit => 'threads_only'}, sub {
		while(1){
			eval{
				while (defined(my $file = $uploadQ->dequeue())){
					my @localtags = (
					  $file->{id},
						qq|dir:filename="$file->{filename}"|,
						qq|meta:id="$file->{id}"|,
						qq|time:modification="$file->{mtime}"|,
						map {qq|dir:step="$_"|} grep {/[^\s]/} split /\//, $file->{filename}
					);
					#print "Prepare to upload $file->{filename}";
					my $photoid = $flickr->upload($file->{filename},@tags, @localtags) or next;
					print "File $file->{filename} uploaded to flickr (photoid = $photoid)";
					$file->{photoid} = $photoid;
					$db->{users}->{$db->{currentUser}}->{files}->{$file->{filename}} = shared_clone $file;
					$db->{users}->{$db->{currentUser}}->{fileIDs}->{$file->{id}} = shared_clone $file;
					$db->{users}->{$db->{currentUser}}->{photoIDs}->{$file->{photoid}} = shared_clone $file;
					countUploadedFiles();				
					$syncDB->();
				}
			};
			(warn "$@\nI will Try again"), next if $@;
			threads->exit();
		}
	});
};
my $joinThreads = sub{
	foreach(keys %threads){
		next unless $threads{$_}->is_running();
		print "Wait for thread $_";
		$threads{$_}->join();
	}
};
my $stopThreads = sub{
	$filesQ->end;
	$fileIDQ->end;
	$checkFlickrQ->end;
	$uploadQ->end;
	$foldersQ->end;
	$joinThreads->();
};
######################End of my code ######################################


package MyApp;
use Wx qw[:everything];
use parent qw(MyFrame);
use strict;
use Data::Dumper;
use Carp;
use threads;
use threads::shared;

######aux functions#########################

sub __showMainPanel{
	my ($self) = @_;
	$self->{mainPanel}->Show(1);
	$self->__hideLoginPanel();
	$self->{mainPanel}->GetParent()->GetSizer()->Layout();
}
sub __hideMainPanel{
	my ($self) = @_;
	$self->{mainPanel}->Show(0);
}
sub __showLoginPanel{
    my ($self) = @_;
	$self-> __hideMainPanel();
	$self->{getTokenPanel}->Show(0);
	$self->{loginPanel}->Show(1);
	$self->{loginPanel}->GetParent()->GetSizer()->Layout();
	$self->__showAskAuthPanel();
}
sub __hideLoginPanel{
	my ($self) = @_;
	$self->{loginPanel}->Show(0);
}
sub __showCheckTokenPanel{
	my ($self) = @_;
	$self->__hideAskAuthPanel();
	$self->{getTokenPanel}->Show(1);
	$self->{getTokenPanel}->GetParent()->GetSizer()->Layout();
}
sub __hideCheckTokenPanel{
	my ($self) = @_;
	$self->{getTokenPanel}->Show(0);
}
sub  __showAskAuthPanel{
	my ($self) = @_;
	$self->__hideCheckTokenPanel();
	$self->{askAuthPanel}->Show(1);
	$self->{askAuthPanel}->GetParent()->GetSizer()->Layout();
}
sub  __hideAskAuthPanel{
	my ($self) = @_;
	$self->{askAuthPanel}->Show(0);
}

sub __setStatus{
	my ($self) = @_;
	if ($db->{currentUser} ne ''){
		$self->SetStatusText(
		  'User '
		  .  $db->{users}->{$db->{currentUser}}->{flickr}->{usr}->{fullname}
		  . '('
		  . $db->{users}->{$db->{currentUser}}->{flickr}->{usr}->{username}
			. ')'
		,0);
	}else{
				$self->SetStatusText('The user is not yet authorized',0);
	}
}

sub __fillFoldersList{
	my ($self) = @_;
	my $p = 0;
	foreach (sort keys $db->{users}->{$db->{currentUser}}->{folders}){
		$self->{foldersList}->InsertStringItem($p++,$_);
	}
}

######end of manual generated functions#########################

sub new {
    my( $self) = @_;
	$self = $self->SUPER::new();

	Wx::Event::EVT_CLOSE($self,sub{
			my ($self, $event) = @_;
			$stopThreads->();
			$syncDB->();
			print "Goodby";
			$event->Skip;
	});

	if($db->{currentUser} ne ''
	   	and defined $db->{users}->{$db->{currentUser}}
	   	and defined $db->{users}->{$db->{currentUser}}->{flickr}
	  	and defined $db->{users}->{$db->{currentUser}}->{flickr}->{usr}
	   	and defined $db->{users}->{$db->{currentUser}}->{flickr}->{usr}->{auth_token}){
		$self->__showMainPanel();
		$self->__fillFoldersList();
	}else{
		$self->__showLoginPanel();
	}
	$self->__setStatus();
	$self->{progressBar}->SetRange(100);
	$self->{progressBar}->SetValue(0);

	return $self;
}

sub go_login {
	my ($self, $event) = @_;
	$self->__showLoginPanel();
	$event->Skip;
}


sub go_logout {
	my ($self, $event) = @_;
	$removeUser->();
	$syncDB->();
	$self->__showLoginPanel();
	$self->SetStatusText('The user is not authorized anymore',0);
	return $event->Skip;
}


my $lastDirectory = "";
sub go_browse {
	my ($self, $event) = @_;
	my $dlg = Wx::DirDialog->new(
	  $self->{backupSubPanel},
	  "Please, choose a folder to backup",
	  $lastDirectory,
	  wxDD_CHANGE_DIR|wxDD_DIR_MUST_EXIST
	);
	if ($dlg->ShowModal == wxID_OK){
		$lastDirectory = $dlg->GetPath();
		my $p = $self->{foldersList}->GetItemCount;
		$self->{foldersList}->InsertStringItem($p,$lastDirectory);
		$db->{users}->{$db->{currentUser}}->{folders}->{$lastDirectory} = time;
	}
	return $event->Skip;
}


sub go_remove_selected {
	my ($self, $event) = @_;
	my $removeFromDB = sub{
		delete $db->{users}->{$db->{currentUser}}->{folders}->{$self->{foldersList}->GetItemText(shift)};
	};
	my $p = $self->{foldersList}->GetFirstSelected;
	$removeFromDB->($p);
	$self->{foldersList}->DeleteItem($p);
	while(($p = $self->{foldersList}->GetNextSelected($p)) >= 0){
		$removeFromDB->($p);
		$self->{foldersList}->DeleteItem($p)
	}
}


sub go_remove_all {
	my ($self, $event) = @_;
	$self->{foldersList}->ClearAll;
	$db->{users}->{$db->{currentUser}}{folders} = {};
	return $event->Skip;
}


sub go_backup {
	my ($self, $event) = @_;
	unless(defined $flickr->{user} and defined $flickr->{user}->{nsid}){
		print "User not login";
		return $self->go_login($event);
	}
	my $count = $self->{foldersList}->GetItemCount;
	my $i = 0;
	$pendigFilesUpdated = 0;
	$uploadFilesUpdated = 0;
	$pendigFiles = 0;
	$uploadFiles = 0;
	async{
		while(1){
			lock($pendigFilesUpdated);
			cond_wait($pendigFilesUpdated) until $pendigFilesUpdated == 1;
			$self->{progressBar}->SetRange($pendigFiles);
		}
	};
	async{
		while(1){
			lock($uploadFilesUpdated);
			cond_wait($uploadFilesUpdated) until $uploadFilesUpdated == 1;
			$self->{progressBar}->SetValue($uploadFiles);
		}
	};
	$startThreads->();
	while($i < $count){
		print $self->{foldersList}->GetItemText($i);
		$foldersQ->enqueue($self->{foldersList}->GetItemText($i++));
	}
	$foldersQ->enqueue(undef); #signal the end of folders list
	async{
		$joinThreads->();
		 $self->{progressBar}->Hide()
	};
	return $event->Skip;
}

sub go_exit {
	my ($self, $event) = @_;
	$self->Close;
	return $event->Skip;
}

sub go_close {
	my ($self, $event) = @_;
	$self->Close;
	return $event->Skip;
}


sub go_main {
	my ($self, $event) = @_;
	$self->__showMainPanel();
	return $event->Skip;
}


sub go_askAuth {
	my ($self, $event) = @_;
	$flickr->askAuth() or carp q|ask auth error|;
	$self->__showCheckTokenPanel();
	return  $event->Skip;
}


sub go_getToken {
	my ($self, $event) = @_;
	print 'Get token...';
	$flickr->getToken() or return $self-> __showAskAuthPanel();
	$self->__showMainPanel();
	$loadUser->();
	$self->__setStatus();
	return $event->Skip;
}
1;

